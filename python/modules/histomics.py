import numpy as np
import scipy.ndimage.filters as filters
from scipy.ndimage.filters import convolve

def eigen(im_hess):
    """
    Calculates the eigenvectors of the hessian volumes 'H'
    generated by Hessian.py
    Parameters
    ----------
    im_hess : array_like
        M x N x 4 hessian matrix - H[:,:,0] = dxx,
        H[:,:,1] = H[:,:,2] = dxy, H[:,:,3] = dyy.
    Returns
    -------
    lamda : array_like
        M x N x 2 image of eigenvalues.
    v1 : array_like
        M x N x 2 eigenvector for lamda(:,:,0)
    v2 :
        M x N x 2 eigenvector for lamda(:,:,1)
    """

    # get size of H
    sizeX = im_hess.shape[0]
    sizeY = im_hess.shape[1]

    # initialize lamda, v1 and v2
    lamda = np.zeros((sizeX, sizeY, 2))
    v1 = np.zeros((sizeX, sizeY, 2))
    v2 = np.zeros((sizeX, sizeY, 2))

    # compute eigenvalues of H
    radical = np.sqrt((im_hess[:, :, 0] - im_hess[:, :, 3]) ** 2 +
                      4 * im_hess[:, :, 1] ** 2)
    lamda[:, :, 0] = (im_hess[:, :, 0] + im_hess[:, :, 3] + radical) / 2
    lamda[:, :, 1] = (im_hess[:, :, 0] + im_hess[:, :, 3] - radical) / 2

    # compute eigenvectors of H
    v1[:, :, 0] = 2 * im_hess[:, :, 1]
    v1[:, :, 1] = im_hess[:, :, 3] - im_hess[:, :, 0] + radical
    norms = np.sqrt(v1[:, :, 0]**2 + v1[:, :, 1]**2)

    # normalize eigenvectors of H
    with np.errstate(divide='ignore', invalid='ignore'):
        v1[:, :, 0] = np.true_divide(v1[:, :, 0], norms)
        v1[:, :, 1] = np.true_divide(v1[:, :, 1], norms)
        # check -inf inf NaN
        v1[:, :, 0][~np.isfinite(v1[:, :, 0])] = 0
        v1[:, :, 1][~np.isfinite(v1[:, :, 1])] = 0
    v2[:, :, 0] = -v1[:, :, 1]
    v2[:, :, 1] = v1[:, :, 0]

    # order by magnitude
    swap = np.where(abs(lamda[:, :, 0]) > abs(lamda[:, :, 1]))

    # swap between lamda[:, :, 0] and lamda[:, :, 1]
    lamda[:, :, 0][swap], lamda[:, :, 1][swap] = \
        lamda[:, :, 1][swap], lamda[:, :, 0][swap]

    # swap between v1 and v2
    v1[:, :, 0][swap], v2[:, :, 0][swap] = \
        v2[:, :, 0][swap], v1[:, :, 0][swap]

    v1[:, :, 1][swap], v2[:, :, 1][swap] = \
        v2[:, :, 1][swap], v1[:, :, 1][swap]

    return lamda, v1, v2

def hessian(im_input, sigma):
    """
    Calculates hessian of image I convolved with a gaussian kernel with
    covariance C = [Sigma^2 0; 0 Sigma^2].
    Parameters
    ----------
    im_input : array_like
        M x N grayscale image.
    sigma : double
        standard deviation of gaussian kernel.
    Returns
    -------
    im_hess : array_like
        M x N x 4 hessian matrix - im_hess[:,:,0] = dxx,
        im_hess[:,:,1] = im_hess[:,:,2] = dxy, im_hess[:,:,3] = dyy.
    """

    # generate kernel domain
    h, k = round(3 * sigma), round(3 * sigma + 1)
    x, y = np.mgrid[-h:k, -h:k]

    # generate kernels
    gxx = 1./(2 * np.pi * sigma ** 4) * ((x / sigma) ** 2 - 1) * \
        np.exp(-(x**2+y**2) / (2 * sigma ** 2))
    gxy = 1./(2 * np.pi * sigma ** 6) * np.multiply(x, y) * \
        np.exp(-(x**2+y**2) / (2 * sigma ** 2))
    gyy = np.transpose(gxx)

    # convolve
    dxx = convolve(im_input, gxx, mode='constant')
    dxy = convolve(im_input, gxy, mode='constant')
    dyy = convolve(im_input, gyy, mode='constant')

    # format output
    im_hess = np.concatenate(
        (dxx[:, :, None], dxy[:, :, None], dxy[:, :, None], dyy[:, :, None]),
        axis=2
    )
    return im_hess

def vesselness(im_input, sigma):
    """
    Calculates vesselness measure for grayscale image `im_input` at scale `sigma`.
    Also returns eigenvalues and vectors used for vessel salience filters.
    Parameters
    ----------
    im_input : array_like
        M x N grayscale image.
    sigma : double
        standard deviation of gaussian kernel.
    Returns
    -------
    Deviation : array_like
        M x N image of deviation from blob
    Frobenius : array_like
        M x N image of frobenius norm of Hessian - measures presence of
        structure.
    E : array_like
        M x N x 2 eigenvalue image - see eigen.py.
    Theta : array_like
        M x N eigenvector angle image for E(:,:,0) in radians
        see eigen.py. Oriented parallel to vessel structures.
    References
    ----------
    .. [#] Frangi, Alejandro F., et al. "Multiscale vessel enhancement
       filtering." Medical Image Computing and Computer-Assisted
       Interventation. MICCAI98. Springer Berlin Heidelberg,1998. 130-137.
    """

    # calculate hessian matrix
    H = sigma ** 2 * hessian(im_input, sigma)

    # calculate eigenvalue image
    E, V1, V2 = eigen(H)

    # compute blobness measures
    Deviation = E[:, :, 0]/(E[:, :, 1] + np.spacing(1))
    Frobenius = np.sqrt(E[:, :, 0]**2 + E[:, :, 1]**2)

    # calculate angles for 'Theta'
    Theta = np.arctan2(V1[:, :, 1], V1[:, :, 0])

    return Deviation, Frobenius, E, Theta

def del2(im_input):
    """Discrete Laplacian with edge-value extrapolation.
    Calculates the discrete Laplacian of an input image. Edge values are
    calculated by using linear extrapolation of second differences. This is
    consistent with the way that Matlab calculates the discrete Laplacian.
    Parameters
    ----------
    im_input : array_like
        A floating-point intensity image.
    Returns
    -------
    im_lap : array_like
        The discrete Laplacian of im_lap.
    See Also
    --------
    histomicstk.segmentation.level_set.reg_edge
    """

    # initialize output
    im_lap = np.zeros(im_input.shape)

    # process rows first
    D = np.diff(im_input, axis=0)
    S = np.zeros(im_input.shape)
    S[1:-1, :] = (D[1:, :] - D[0:-1, :])/2
    if im_input.shape[0] > 3:
        S[0, :] = 2 * S[1, :] - S[2, :]
        S[-1, :] = 2 * S[-2, :] - S[-3, :]
    elif im_input.shape[0] == 3:
        S[0, :] = S[1, :]
        S[-1, :] = S[1, :]
    else:
        S[0, :] = 0
        S[-1, :] = 0
    im_lap += S

    # process columns
    D = np.diff(im_input, axis=1)
    S = np.zeros(im_input.shape)
    S[:, 1:-1] = (D[:, 1:] - D[:, 0:-1])/2
    if im_input.shape[1] > 3:
        S[:, 0] = 2 * S[:, 1] - S[:, 2]
        S[:, -1] = 2 * S[:, -2] - S[:, -3]
    elif im_input.shape[1] == 3:
        S[0, :] = S[:, 1]
        S[:, -1] = S[:, 1]
    else:
        S[:, 0] = 0
        S[:, -1] = 0
    im_lap += S

    return im_lap / 2

def reg_edge(im_input, im_phi, well='double', sigma=1.5, dt=1.0, mu=0.2,
             lamda=1, alpha=-3, epsilon=1.5, iter=100):
    """Distance-regularized edge-based level sets.
    Distance-regularization is used in this edge-based level set implementation
    to avoid numerical problems requiring costly re-initialization. Provides
    cost terms for boundary length, area, and regularization of the level set
    function. Foreground objects are assumed to have larger intensity values
    than background.
    Parameters
    ----------
    im_input : array_like
        A floating-point intensity image.
    im_phi : array_like
        A floating-point initalization of the level-set image. Interior values
        are set to -c0, and exterior values set to c0, where c0 > 0.
    well : string
        Choice of well function for regularization. Can be set to either
        'single' or 'double' for single-well or double-well regularization, or
        any other value for no regularization. Default value = 'double'.
    sigma : double
        Standard deviation of smoothing filter for input image im_input.
    dt : double
        Time step for evolving im_phi. Default value = 1.0.
    mu : double
        Regularization weight for energy function. Default value = 0.2.
    lamda : double
        Boundary length weight for energy function. Default value = 1.0.
    alpha : double
        Area weight for energy function. A negative value is used to seed the
        interior of the foreground objects and then evolve the boundary
        outwards. A positive value assumes that the boundary begins outside the
        foreground objects and collapses to their high-gradient edges.
        Default value = -3.
    epsilon: double
        Coefficient used to smooth the Dirac and Heaviside functions. Default
        value = 1.5.
    iter: double
        Number of iterations to evolve curve level set function over. Default
        value = 100.
    Returns
    -------
    im_phi : array_like
        An intensity image where the zero level set defines object boundaries.
        Can be further processed with fast marching methods or other to obtain
        smooth boundaries, or simply thresholded to define the object mask.
    See Also
    --------
    histomicstk.segmentation.nuclear.gaussian_voting
    References
    ----------
    .. [#] C. Li, C. Xu, C. Gui, M.D. Fox, "Distance Regularized Level Set
       Evolution and Its Application to Image Segmentation," in IEEE
       Transactions on Image Processing, vol.19,no.12,pp.3243-54, 2010.
    """

    # smoothed gradient of input image
    sI = filters.gaussian_filter(im_input, sigma, mode='constant', cval=0)
    dsI = np.gradient(sI)
    G = 1/(1 + dsI[0]**2 + dsI[1]**2)
    dG = np.gradient(G)

    # perform regularized level-set evolutions with time step dt
    for i in range(0, iter):

        # fix boundary conditions
        im_phi = neumann_bounds(im_phi)

        # calculate gradient of level set image
        dPhi = np.gradient(im_phi)
        mPhi = (dPhi[0]**2 + dPhi[1]**2)**0.5  # gradient magnitude
        Curve = np.gradient(dPhi[0] / (mPhi + 1e-10))[0] + \
            np.gradient(dPhi[1] / (mPhi + 1e-10))[1]  # divergence

        # build regularization function
        if well == 'single':
            Reg = single_well(im_phi, Curve)
        elif well == 'double':
            Reg = double_well(im_phi, dPhi, mPhi, Curve, i)
        else:
            Reg = np.zeros(im_phi.shape)

        # area and boundary-length energy function terms
        iPhi = impulse(im_phi, epsilon)
        Area = iPhi * G
        Edge = iPhi * (dG[0] * (dPhi[0] / (mPhi + 1e-10)) +
                       dG[1] * (dPhi[1] / (mPhi + 1e-10))) + iPhi * G * Curve

        # evolve level-set function
        im_phi = im_phi + dt * (mu * Reg + lamda * Edge + alpha * Area)

    # return evolved level-set function following iterations
    return im_phi


def initialize(Mask, c0=2):
    # initialize scaled binary-step image
    Phi0 = np.zeros(Mask.shape)
    Phi0[Mask > 0] = -c0
    Phi0[Mask == 0] = c0
    return Phi0


def single_well(Phi, Curve):
    # Single-well potential function
    return 4 * del2(Phi)-Curve


def double_well(Phi, dPhi, mPhi, Curve, i):
    # Double-well potential function
    SmallMask = (mPhi <= 1) & (mPhi >= 0)
    LargeMask = (mPhi > 1)
    P = SmallMask * np.sin(2 * np.pi * mPhi) / \
        (2 * np.pi) + LargeMask * (mPhi - 1)
    dP = ((P != 0) * P + (P == 0)) / ((mPhi != 0) * mPhi + (mPhi == 0))
    Well = np.gradient(dP * dPhi[0] - dPhi[0])[0] + \
        np.gradient(dP * dPhi[1] - dPhi[1])[1] + 4 * del2(Phi)
    return Well


def impulse(X, Epsilon):
    # Smooth dirac delta function.

    # calculate smoothed impulse everywhere
    Xout = (1 + np.cos(np.pi * X / Epsilon)) / (2 * Epsilon)

    # zero out values |x| > Epsilon
    Xout[np.absolute(X) > Epsilon] = 0

    return Xout


def neumann_bounds(Phi):
    # Transofrm input to enforce Neumann boundary conditions.

    # copy input
    PhiOut = Phi

    # capture image size
    m = Phi.shape[0]
    n = Phi.shape[1]

    # deal with corners
    PhiOut[0, 0] = PhiOut[2, 2]
    PhiOut[0, n-1] = PhiOut[0, -3]
    PhiOut[m-1, 0] = PhiOut[-3, 2]
    PhiOut[m-1, n-1] = PhiOut[-3, -3]

    # deal with edges
    PhiOut[0, 1:-1] = PhiOut[2, 1:-1]
    PhiOut[m-1, 1:-1] = PhiOut[m-3, 1:-1]
    PhiOut[1:-1, 0] = PhiOut[1:-1, 2]
    PhiOut[1:-1, n-1] = PhiOut[1:-1, n-3]

    return PhiOut
